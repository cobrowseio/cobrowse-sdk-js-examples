<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>WebRTC Camera</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <script>
    var urlParams = new URLSearchParams(window.location.search);

    (function(w,t,c,p,s,e){p=new Promise(function(r){w[c]={client:function(){if(!s){
    s=document.createElement(t);s.src='https://js.cobrowse.io/CobrowseIO.js';s.async=1;
    e=document.getElementsByTagName(t)[0];e.parentNode.insertBefore(s,e);s.onload=function()
    {r(w[c]);};}return p;}};});})(window,'script','CobrowseIO');

    // FOR SECURITY REASONS DO NOT SET YOUR LICENSE KEY OR API USING QUERY PARAMETERS IN YOUR OWN APPLICATION
    CobrowseIO.license = urlParams.get('license') || 'trial'; // change to your license key
    CobrowseIO.api = urlParams.get('api') || 'https://api.cobrowse.io';
    CobrowseIO.client().then(() => {
      CobrowseIO.start();
    });
  </script>

  <style>
    body {
      display: flex;
      flex-direction: column;
      /* justify-content: space-between; */
      align-items: center;
      height: 100vh;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      font-family: Arial, sans-serif;
      overflow: hidden; /* Prevent scrolling */

      /* Safe area padding */
      padding-bottom: env(safe-area-inset-bottom);
      padding-top: env(safe-area-inset-top);
    }

    h1 {
      margin-top: 2%;
      color: #505050;
    }

    #canvas {
      width: calc(100% - 40px);
      margin: 20px;
      flex: 1;
      object-fit: cover;
      max-height: calc(100% - 180px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
    }

    .button-container {
      display: flex;
      justify-content: center;
      position: fixed;
      bottom: env(safe-area-inset-bottom); /* Position at the bottom, considering safe area */
      left: 0;
      width: 100%;
      padding-bottom: env(safe-area-inset-bottom);
      background-color: #ffffff;
      box-shadow: 0px -2px 10px rgba(0, 0, 0, 0.1);
    }

    #cameraButton,
    #switchButton {
      margin: 10px;
      padding: 15px 25px;
      border: none;
      border-radius: 5px;
      background-color: rgb(97, 0, 255);
      color: #ffffff;
      font-size: 1em;
      transition: background-color 0.3s;
    }

    #cameraButton:hover,
    #switchButton:hover {
      background-color: rgb(75, 0, 200);
    }

    #switchButton {
      display: none;
    }

    @media (max-width: 375px) and (max-height: 812px) and (-webkit-device-pixel-ratio: 3) {
      body {
        padding-bottom: calc(env(safe-area-inset-bottom) + 44px); /* Additional padding for the home indicator */
      }

      .button-container {
        padding-bottom: calc(env(safe-area-inset-bottom) + 34px); /* Additional padding for the home indicator */
      }
    }
  </style>
</head>

<body>
  <h1>WebRTC Camera</h1>
  <canvas id="canvas" data-framecount="0"></canvas>
  <div class="button-container">
    <button id="cameraButton">Start Camera</button>
    <button id="switchButton">Switch Camera</button>
  </div>

  <script>
    // Check for browser compatibility
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      const videoElement = document.createElement('video');
      videoElement.setAttribute('playsinline', '');
      videoElement.style.display = 'none';

      const canvas = document.getElementById('canvas');
      const context = canvas.getContext('2d');

      let currentStream;
      let frameCount = 0;

      const cameraButton = document.getElementById('cameraButton');
      const switchButton = document.getElementById('switchButton');

      cameraButton.addEventListener('click', () => {
        if (!currentStream) {
          navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
            .then((stream) => {
              videoElement.srcObject = stream;
              videoElement.play();
              currentStream = stream;
              cameraButton.textContent = "Stop Camera";
              switchButton.style.display = "inline-block";

              videoElement.onloadedmetadata = () => {
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;

                const drawVideoFrame = () => {
                  context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                  requestAnimationFrame(drawVideoFrame);
                };

                drawVideoFrame();
              };
            })
            .catch((error) => {
              console.error('Error accessing the camera: ', error);
            });
        } else {
          // Stop the current camera stream
          currentStream.getTracks().forEach((track) => {
            track.stop();
          });

          currentStream = null;
          context.clearRect(0, 0, canvas.width, canvas.height);
          cameraButton.textContent = "Start Camera";
          switchButton.style.display = "none";
        }
      });

      switchButton.addEventListener('click', () => {
        if (currentStream) {
          const tracks = currentStream.getTracks();

          // Stop the current camera stream
          tracks.forEach((track) => {
            track.stop();
          });

          // Get the current facing mode of the video track
          const currentFacingMode = tracks[0].getSettings().facingMode;

          // Define the new facing mode to switch to
          const newFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';

          // Create the new constraints object with the new facing mode
          const constraints = { video: { facingMode: newFacingMode } };

          // Start the new camera stream with the updated constraints
          navigator.mediaDevices.getUserMedia(constraints)
            .then((stream) => {
              videoElement.srcObject = stream;
              videoElement.play();
              currentStream = stream;
            })
            .catch((error) => {
              console.error('Error switching camera: ', error);
            });
        }
      });

      // Timer to increment frame count every 500 milliseconds
      setInterval(() => {
        frameCount++;
        canvas.dataset.framecount = frameCount;
      }, 500);

      // Attach the video element to the document
      document.body.appendChild(videoElement);
    } else {
      console.error('WebRTC is not supported in this browser.');
    }
  </script>
</body>

</html>
